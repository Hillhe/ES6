<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>let命令</title>
</head>
<body>
    
</body>
<script>
console.log(
` 一、基本用法
    1.只能在let所在命令的代码块内有效,外部会报错
    【*for循环特别之处】：就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
`)
// 1
{
    let a = 10;
    var b = 20;
}
// console.log(a, b)
// 【*for循环特别之处】
for(let i = 0; i < 3; i++) {
    let i = "hhh";
    console.log(i)
}
console.log(
` 二、不存在变量提升
    1.let声明的变量只能在声明之后使用，否则报错 
    【var变量提升】：即变量可以在声明之前使用，但值为undefined
`)
// 1
// console.log(boo); //Uncaught ReferenceError: Cannot access 'boo' before initialization
let boo = '13';
console.log(boo);
// 【var变量提升】
console.log(foo);
var foo = 'test';
console.log(
` 三、暂时性死区：
    1.只要块级作用域内存在let声明的变量，它所声明的变量就会绑定这个区域，不会受外部的影响
    【暂时性死区意味着typeof不再是100%的安全操作, 如果一个变量没有被声明，使用typeof反而不会报错】
    【暂时性死区】：在代码块内，使用let,const命令声明变量之前，该变量都是不可用的，这被称为暂时性死区
`)
// 1
var temp = 'temp'; //全局变量temp
if(true) {
    // temp = 'abl'; //Uncaught ReferenceError: Cannot access 'temp' before initialization
    let temp; //局部变量temp,与当前作用域绑定
}
// 【暂时性死区意味着typeof不再是100%的安全操作】
// typeof x //2-1let命令.html:54 Uncaught ReferenceError: Cannot access 'x' before initialization
let x;
console.log(typeof lalal) //undefined
console.log(
` 四、不予许重复声明：
    1.let不允许在相同的作用域内重复声明一个变量
    2.块级作用域
        2-1：为什么需要块级作用域？
            （1）内层变量可能会覆盖外层变量
            （2）用来计数的循环变量泄露为全局变量
    3.es6的块级作用域
        //TODO
    【es5只有全局作用域和函数作用域，没有块级作用域】
`)
// 2-1-（1）
var tmp = new Date();
function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}
f(); // undefined， 变量提升
// 2-1-（2）
var s = 'hello';
for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}
console.log(i); // 5
</script>
</html>